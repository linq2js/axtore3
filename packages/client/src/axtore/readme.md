# `AXTORE`

Apollo store for Axon web app

## Core concepts

There are 6 core concepts in Axtore: Model, State, Query, Mutation, Event, Effect

- Model: Encapsulates the logic and required state of an independent module, consisting of States, Queries, Mutations, Events and Effects. The app or app feature can have multiple models
- State: The state stored in the Model. Accessing and updating state must be done synchronously.
- Mutation: Encapsulates the logic to mutate model states and query data. It supports asynchronous updating.
- Query: Encapsulates the fetching logic.
- Event: The app uses events to communicate between multiple models.
- Effect: Encapsulates the logic will run once the model is ready

## Basic usage

Next, let's take a simple Counter application as an example to demonstrate the basic usage of Axtore.

```tsx
import { model } from "@axon/axtore";

const counterModel = model().state("count", 0);
```

We use the API model to create counterModel, which currently only contains the state that stores the `count` value, that is, value in the code.

We define an action to increase the `count` by 1:

```tsx
import { model } from "@axon/axtore";

const counterModel = model()
  .state("count", 0)
  .mutation("add", ({ $count }) => {
    $count($count() + 1);
  });
```

In the `add` action, we can use `$count` getter and setter modify the value of the `count` state.
The `$count` state accessor is generated by Axtore automatically. For example if you define `abc` state, its accessor will be `$abc`.
The `$count` accessor also has some overloads:

```ts
$count(); // return current state

// passing reducer like Redux
$count((prev) => prev + 1);

// we also can mutate complex object with ease because Axtore integrates with Immer under the hood
$person((draft) => {
  draft.name = "New name";
});
```

Next, we will demonstrate how to use the Model in a component.

We need to setup an Apollo client first

```ts
import { ApolloClient, InMemoryCache, ApolloProvider } from "@apollo/client";

const client = new ApolloClient({
  cache: new InMemoryCache(),
  ...otherConfigs,
});

const App = () => {
  return (
    <ApolloProvider client={client}>
      <Counter /> // will define this component later
    </ApolloProvider>
  );
};
```

Let's create a Counter component and use the countModel via the generated hooks:

```ts
import { hooks } from "@axon/axtore/react";
import countModel from "./models/count";

// useAdd and useCount hooks are created by hooks API,
// the hook name is following pattern `useXXX` where XXX is state/query/mutation/event name
const { useAdd, useCount } = hooks(countModel.meta);

function Counter() {
  const count = useCount();
  const add = useAdd();

  return (
    <div>
      <div>counter: {count}</div>
      <button onClick={() => add()}>add</button>
    </div>
  );
}
```

## Define a model

In the previous section, we demonstrated how to create a Model for a simple counter application. In this section, we will provide a detailed introduction on how to create a Model.

```ts
import { model, gql } from "@axon/axtore";

const appModel = model()
  // define `count` state and set to 1
  .state("count", 1)
  // define computed state, when `count` state changed, `doubledCount` state re-computes as well
  .state("doubledCount", (context) => {
    // destructure `count` accessor from the context
    const { $count } = context;
    // return doubled value
    return $count() * 2;
  })
  .state("filter", "all" as "all" | "completed" | "active")
  .query(
    // define a graphql query
    "todoList",
    // using gql function to create strong typed query document
    gql<
      // variables type
      { page: number; limit: number },
      // result type
      { todos: Todo[] }
    >`
      query GetTodoList($page: Int, limit: Int) {
        todos(page: $page, limit: $limit) {
          id
          title
        }
      }
    `
  )
  .query("filteredTodos", async (context) => {
    // destructure todoList query accessor from the context
    const { $todoList, $filter } = context;
    // get filter value
    const filter = $filter();
    // call todoList query and wait for the result
    const { todos } = await $todoList();

    // filteredTodos query consumes `filter` state and `todoList` query data, whenever these changed, filteredTodos also does re-computing

    return filter === "completed"
      ? // filter completed todos
        todos.filter((x) => x.completed)
      : filter === "active"
      ? // filter active todos
        todos.filter((x) => !x.completed)
      : // all todos
        todos;
  });
```
